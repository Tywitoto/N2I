<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake — HTML5 Canvas</title>
  <style>
    :root{
      --bg:#0f1724; /* dark navy */
      --panel:#0b1220;
      --accent:#22c55e; /* green */
      --muted:#94a3b8;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.04);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:linear-gradient(180deg,#071027 0%, #071422 100%);
      color: #e6eef8;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:20px;
    }
    .wrap{
      width:100%;
      max-width:980px;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:18px;
      align-items:start;
    }
    .card{
      background:var(--panel);
      border-radius:14px;
      padding:16px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.03);
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:8px;
      background:linear-gradient(180deg,#061126,#07122a);
    }
    h1{font-size:20px;margin:0 0 10px 0}
    .controls{display:flex;flex-direction:column;gap:12px}
    .row{display:flex;gap:8px}
    .btn{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
    .btn.primary{background:linear-gradient(90deg,#123 0%, #014);color:var(--accent);border-color:rgba(34,197,94,0.12)}
    .info{display:flex;flex-direction:column;gap:6px}
    .stat{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
    .foot{font-size:12px;color:var(--muted);margin-top:12px}
    .touch-controls{display:none;gap:8px;justify-content:center}
    .touch-btn{width:48px;height:48px;border-radius:8px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-weight:600}
    @media (max-width:880px){
      .wrap{grid-template-columns:1fr;}
      .touch-controls{display:flex}
    }
    /* small accessibility focus styles */
    .btn:focus{outline:2px solid rgba(34,197,94,0.18)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Snake (HTML5)</h1>
      <canvas id="game" width="640" height="640" aria-label="Snake game canvas"></canvas>
      <div class="touch-controls" id="touchControls" aria-hidden="true">
        <div style="display:flex;flex-direction:column;gap:8px;align-items:center">
          <div class="touch-btn" data-dir="up">↑</div>
          <div style="display:flex;gap:8px"><div class="touch-btn" data-dir="left">←</div><div class="touch-btn" data-dir="right">→</div></div>
          <div class="touch-btn" data-dir="down">↓</div>
        </div>
      </div>
      <p class="foot">Use arrows or WASD to move. Tap the touch buttons on mobile. Game saves high score locally.</p>
    </div>

    <div class="card">
      <div class="controls">
        <div class="row">
          <button class="btn primary" id="startBtn">Start / Restart</button>
          <button class="btn" id="pauseBtn">Pause</button>
        </div>

        <div class="info">
          <div class="stat"><span>Score</span><strong id="score">0</strong></div>
          <div class="stat"><span>High score</span><strong id="highscore">0</strong></div>
          <div class="stat"><span>Speed</span><strong id="speedLabel">Normal</strong></div>
        </div>

        <div>
          <label style="font-size:13px;color:var(--muted)">Grid size</label>
          <div class="row" style="margin-top:6px">
            <select id="gridSelect" class="btn" style="padding-right:6px">
              <option value="16">16 × 16 (small)</option>
              <option value="24" selected>24 × 24 (normal)</option>
              <option value="64">64 × 64 (large)</option>
            </select>
            <select id="speedSelect" class="btn">
              <option value="8">Slow</option>
              <option value="12" selected>Normal</option>
              <option value="16">Fast</option>
              <option value="22">Very fast</option>
            </select>
          </div>
        </div>

        <div style="margin-top:10px">
          <label style="font-size:13px;color:var(--muted)">Mode</label>
          <div class="row" style="margin-top:6px">
            <button class="btn" id="wrapToggle">Wrap: ON</button>
            <button class="btn" id="gridToggle">Show Grid: OFF</button>
          </div>
        </div>

        <div style="margin-top:10px">
          <label style="font-size:13px;color:var(--muted)">Quick actions</label>
          <div class="row" style="margin-top:6px">
            <button class="btn" id="seedFood">Place food</button>
            <button class="btn" id="saveHS">Reset Highscore</button>
          </div>
        </div>

      </div>
    </div>
  </div>

 <script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // UI
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('highscore');
  const gridSelect = document.getElementById('gridSelect');
  const speedSelect = document.getElementById('speedSelect');
  const wrapToggle = document.getElementById('wrapToggle');
  const gridToggle = document.getElementById('gridToggle');
  const seedFoodBtn = document.getElementById('seedFood');
  const saveHSBtn = document.getElementById('saveHS');
  const touchControls = document.getElementById('touchControls');
  const speedLabel = document.getElementById('speedLabel');

  let GRID = parseInt(gridSelect.value,10);
  let CELL = 0;
  let speed = parseInt(speedSelect.value,10); // ticks per second
  let tickInterval = 1000 / speed;
  let showGrid = false;
  let wrap = true;

  let snake = []; // array of {x,y}
  let dir = {x:1,y:0};
  let nextDir = null;
  let food = null;
  let score = 0;
  let highscore = parseInt(localStorage.getItem('snake.high')||'0',10);
  let running = false;
  let paused = false;
  let lastTick = 0;
  let gameOver = false;

  highEl.textContent = highscore;
  scoreEl.textContent = score;

  function reset(){
    GRID = parseInt(gridSelect.value,10);
    // DO NOT use canvas.width (device pixels) here — use CELL set by resizeCanvas (CSS pixels)
    // If CELL was not set yet, compute from bounding rect:
    if(!CELL || CELL === 0){
      const rect = canvas.getBoundingClientRect();
      CELL = rect.width / GRID;
    } else {
      CELL = (parseFloat(canvas.style.width) || canvas.getBoundingClientRect().width) / GRID;
    }

    speed = parseInt(speedSelect.value,10);
    tickInterval = 1000 / speed;
    snake = [];
    const startLen = Math.max(3, Math.floor(GRID/6));
    const cx = Math.floor(GRID/2);
    const cy = Math.floor(GRID/2);
    for(let i=0;i<startLen;i++) snake.push({x:cx-i,y:cy});
    dir = {x:1,y:0};
    nextDir = null;
    score = 0;
    gameOver = false;
    placeFood();
    scoreEl.textContent = score;
    pauseBtn.textContent = 'Pause';
  }

  function placeFood(){
    // correct random bounds and avoid -1
    for(let attempts=0;attempts<1000;attempts++){
      const x = Math.floor(Math.random() * GRID);
      const y = Math.floor(Math.random() * GRID);
      if(!snake.some(s=>s.x===x && s.y===y)){
        food = {x,y};
        return;
      }
    }
    // fallback: scan for empty cell
    for(let y=0;y<GRID;y++){
      for(let x=0;x<GRID;x++){
        if(!snake.some(s=>s.x===x && s.y===y)){
          food = {x,y};
          return;
        }
      }
    }
  }

  function setHighscore(v){
    highscore = Math.max(highscore, v);
    localStorage.setItem('snake.high', String(highscore));
    highEl.textContent = highscore;
  }

  function tick(){
    if(paused || gameOver) return;
    if(nextDir){
      if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;
      nextDir = null;
    }
    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};
    if(wrap){
      head.x = (head.x + GRID) % GRID;
      head.y = (head.y + GRID) % GRID;
    } else {
      if(head.x < 0 || head.y < 0 || head.x >= GRID || head.y >= GRID){
        return onDeath();
      }
    }
    if(snake.some(s => s.x===head.x && s.y===head.y)) return onDeath();
    snake.unshift(head);
    if(food && head.x===food.x && head.y===food.y){
      score += Math.floor(10 + GRID/2);
      scoreEl.textContent = score;
      placeFood();
      setHighscore(score);
    } else {
      snake.pop();
    }
  }

  function onDeath(){
    gameOver = true;
    running = false;
    paused = false;
  }

  function render(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw background using transformed coordinates (we set transform in resizeCanvas)
    ctx.save();
    // drawing in CSS pixel coordinates now
    ctx.fillStyle = '#051225';
    ctx.fillRect(0,0,w,h);

    if(showGrid){
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      for(let i=0;i<=GRID;i++){
        const x = i * CELL;
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
      }
      for(let i=0;i<=GRID;i++){
        const y = i * CELL;
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
      }
    }

    // food
    if(food){
      drawCell(food.x, food.y, function(innerX, innerY, cellSize){
        ctx.fillStyle = 'rgba(255,80,80,0.95)';
        const pad = Math.max(2, cellSize*0.12);
        ctx.beginPath();
        roundRect(ctx, innerX+pad, innerY+pad, cellSize-2*pad, cellSize-2*pad, 6);
        ctx.fill();
      });
    }

    // snake body
    for(let i=snake.length-1;i>=0;i--){
      const s = snake[i];
      const t = i===0 ? 0.95 : (i/snake.length);
      drawCell(s.x,s.y,(ix,iy,cellSize)=>{
        const base = hexToRgb('#22c55e');
        ctx.fillStyle = `rgba(${base.r},${base.g},${base.b},${0.35 + 0.65*t})`;
        roundRect(ctx, ix+1, iy+1, cellSize-2, cellSize-2, Math.max(3, Math.floor(cellSize*0.12)));
        ctx.fill();
      });
    }

    // overlay: score
    ctx.font = '14px system-ui, Arial';
    ctx.fillStyle = 'rgba(230,238,248,0.9)';
    ctx.fillText('Score: ' + score, 8, 18);
    ctx.fillStyle = 'rgba(148,163,184,0.6)';
    ctx.fillText('High: ' + highscore, 8, 36);

    if(gameOver){
      ctx.fillStyle = 'rgba(2,6,23,0.6)';
      ctx.fillRect(0, h/2 - 48, w, 96);
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.font = '24px system-ui, Arial';
      ctx.fillText('Game Over — Press Start to play again', w/2, h/2+8);
      ctx.textAlign = 'left';
    }

    ctx.restore();
  }

  function drawCell(gridX, gridY, fn){
    const x = Math.floor(gridX * CELL);
    const y = Math.floor(gridY * CELL);
    fn(x,y,CELL);
  }

  function gameLoop(ts){
    if(!lastTick) lastTick = ts;
    const elapsed = ts - lastTick;
    if(elapsed >= tickInterval){
      const ticks = Math.floor(elapsed / tickInterval);
      for(let i=0;i<ticks;i++) tick();
      lastTick = ts - (elapsed % tickInterval);
    }
    render();
    requestAnimationFrame(gameLoop);
  }

  // --- input handling ---
  window.addEventListener('keydown', e=>{
    if(e.key === 'ArrowUp' || e.key === 'z' || e.key === 'Z') nextDir = {x:0,y:-1};
    if(e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') nextDir = {x:0,y:1};
    if(e.key === 'ArrowLeft' || e.key === 'q' || e.key === 'Q') nextDir = {x:-1,y:0};
    if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') nextDir = {x:1,y:0};
    if(e.key === ' '){ togglePause(); }
  });

  document.querySelectorAll('[data-dir]').forEach(btn=>{
    btn.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); const d = btn.dataset.dir; handleDir(d); });
    btn.addEventListener('mousedown', ()=>{ handleDir(btn.dataset.dir); });
  });

  function handleDir(d){
    if(d==='up') nextDir = {x:0,y:-1};
    if(d==='down') nextDir = {x:0,y:1};
    if(d==='left') nextDir = {x:-1,y:0};
    if(d==='right') nextDir = {x:1,y:0};
  }

  (function(){
    let startX=0,startY=0,tracking=false;
    canvas.addEventListener('touchstart', e=>{
      const t = e.touches[0]; startX = t.clientX; startY = t.clientY; tracking = true;
    });
    canvas.addEventListener('touchmove', e=>{
      if(!tracking) return; const t = e.touches[0]; const dx = t.clientX - startX; const dy = t.clientY - startY; if(Math.hypot(dx,dy) > 30){
        tracking=false; if(Math.abs(dx) > Math.abs(dy)) dx>0 ? handleDir('right') : handleDir('left'); else dy>0 ? handleDir('down') : handleDir('up');
      }
    });
    canvas.addEventListener('touchend', ()=>{ tracking=false; });
  })();

  // UI bindings
  startBtn.addEventListener('click', ()=>{
    reset(); running = true; paused = false; lastTick = 0; requestAnimationFrame(gameLoop);
  });
  pauseBtn.addEventListener('click', togglePause);
  gridSelect.addEventListener('change', ()=>{ reset(); render(); });
  speedSelect.addEventListener('change', ()=>{ speed = parseInt(speedSelect.value,10); tickInterval = 1000 / speed; speedLabel.textContent = speedSelect.options[speedSelect.selectedIndex].text; });
  wrapToggle.addEventListener('click', ()=>{ wrap = !wrap; wrapToggle.textContent = 'Wrap: ' + (wrap ? 'ON' : 'OFF'); });
  gridToggle.addEventListener('click', ()=>{ showGrid = !showGrid; gridToggle.textContent = 'Show Grid: ' + (showGrid ? 'ON' : 'OFF'); });
  seedFoodBtn.addEventListener('click', ()=>{ placeFood(); });
  saveHSBtn.addEventListener('click', ()=>{ localStorage.removeItem('snake.high'); highscore = 0; highEl.textContent = 0; });

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if(!paused && running) lastTick = performance.now();
  }

  // utilities
  function roundRect(ctx,x,y,w,h,r){ if(typeof r==='undefined') r=4; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function hexToRgb(hex){ const m = hex.replace('#',''); return {r: parseInt(m.substring(0,2),16), g: parseInt(m.substring(2,4),16), b: parseInt(m.substring(4,6),16)} }

  // handle retina and responsive sizing
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const size = Math.min(rect.width, window.innerHeight - 140);
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(size * dpr);
    canvas.height = Math.floor(size * dpr);
    canvas.style.height = size + 'px';
    canvas.style.width = size + 'px';
    // set transform so drawing uses CSS pixels
    ctx.setTransform(dpr,0,0,dpr,0,0);
    // CELL is CSS pixels per grid cell
    GRID = parseInt(gridSelect.value,10);
    CELL = size / GRID;
    render();
  }
  window.addEventListener('resize', resizeCanvas);

  // init
  (function init(){
    resizeCanvas();
    reset();
    if(window.innerWidth <= 880) touchControls.setAttribute('aria-hidden','false');
    render();
  })();

})();
</script>

</body>
</html>
